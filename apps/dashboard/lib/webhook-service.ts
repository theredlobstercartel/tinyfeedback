/**
 * Webhook Service
 * ST-11: Webhooks e Integrações
 * 
 * Service for managing webhooks and retrieving delivery logs
 */

import { createClient } from './supabase/client'
import {
  Webhook,
  WebhookDelivery,
  WebhookStats,
  CreateWebhookInput,
  UpdateWebhookInput,
  WebhookTestResult,
} from '@/types/webhook'

const supabase = createClient()

/**
 * Get all webhooks for a project
 */
export async function getWebhooks(projectId: string): Promise<Webhook[]> {
  const { data, error } = await supabase
    .from('webhooks')
    .select('*')
    .eq('project_id', projectId)
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Error fetching webhooks:', error)
    throw new Error('Failed to fetch webhooks')
  }

  return data || []
}

/**
 * Get a single webhook by ID
 */
export async function getWebhook(webhookId: string): Promise<Webhook | null> {
  const { data, error } = await supabase
    .from('webhooks')
    .select('*')
    .eq('id', webhookId)
    .single()

  if (error) {
    console.error('Error fetching webhook:', error)
    throw new Error('Failed to fetch webhook')
  }

  return data
}

/**
 * Create a new webhook
 */
export async function createWebhook(input: CreateWebhookInput): Promise<Webhook> {
  const { data, error } = await supabase
    .from('webhooks')
    .insert({
      project_id: input.project_id,
      name: input.name,
      url: input.url,
      events: input.events,
      template: input.template || 'default',
      custom_headers: input.custom_headers,
      max_retries: input.max_retries || 3,
      description: input.description,
      secret: '', // Will be auto-generated by database
    })
    .select()
    .single()

  if (error) {
    console.error('Error creating webhook:', error)
    throw new Error('Failed to create webhook')
  }

  return data
}

/**
 * Update a webhook
 */
export async function updateWebhook(
  webhookId: string,
  input: UpdateWebhookInput
): Promise<Webhook> {
  const updateData: Record<string, unknown> = {}

  if (input.name !== undefined) updateData.name = input.name
  if (input.url !== undefined) updateData.url = input.url
  if (input.events !== undefined) updateData.events = input.events
  if (input.template !== undefined) updateData.template = input.template
  if (input.custom_headers !== undefined) updateData.custom_headers = input.custom_headers
  if (input.max_retries !== undefined) updateData.max_retries = input.max_retries
  if (input.description !== undefined) updateData.description = input.description
  if (input.status !== undefined) updateData.status = input.status

  const { data, error } = await supabase
    .from('webhooks')
    .update(updateData)
    .eq('id', webhookId)
    .select()
    .single()

  if (error) {
    console.error('Error updating webhook:', error)
    throw new Error('Failed to update webhook')
  }

  return data
}

/**
 * Delete a webhook
 */
export async function deleteWebhook(webhookId: string): Promise<void> {
  const { error } = await supabase
    .from('webhooks')
    .delete()
    .eq('id', webhookId)

  if (error) {
    console.error('Error deleting webhook:', error)
    throw new Error('Failed to delete webhook')
  }
}

/**
 * Regenerate webhook secret
 */
export async function regenerateWebhookSecret(webhookId: string): Promise<string> {
  const { data, error } = await supabase
    .rpc('regenerate_webhook_secret', {
      p_webhook_id: webhookId,
    })

  if (error) {
    console.error('Error regenerating webhook secret:', error)
    throw new Error('Failed to regenerate webhook secret')
  }

  return data
}

/**
 * Get webhook delivery logs
 */
export async function getWebhookDeliveries(
  projectId: string,
  options: {
    webhookId?: string
    status?: string
    limit?: number
    offset?: number
  } = {}
): Promise<{ deliveries: WebhookDelivery[]; count: number }> {
  let query = supabase
    .from('webhook_deliveries')
    .select('*', { count: 'exact' })
    .eq('project_id', projectId)

  if (options.webhookId) {
    query = query.eq('webhook_id', options.webhookId)
  }

  if (options.status) {
    query = query.eq('status', options.status)
  }

  query = query
    .order('created_at', { ascending: false })
    .range(
      options.offset || 0,
      (options.offset || 0) + (options.limit || 20) - 1
    )

  const { data, error, count } = await query

  if (error) {
    console.error('Error fetching webhook deliveries:', error)
    throw new Error('Failed to fetch webhook deliveries')
  }

  return {
    deliveries: data || [],
    count: count || 0,
  }
}

/**
 * Get webhook delivery statistics
 */
export async function getWebhookStats(
  projectId: string,
  days: number = 30
): Promise<WebhookStats> {
  const { data, error } = await supabase
    .rpc('get_webhook_stats', {
      p_project_id: projectId,
      p_days: days,
    })

  if (error) {
    console.error('Error fetching webhook stats:', error)
    throw new Error('Failed to fetch webhook stats')
  }

  return data?.[0] || {
    total_deliveries: 0,
    successful_deliveries: 0,
    failed_deliveries: 0,
    retrying_deliveries: 0,
    success_rate: 0,
    avg_duration_ms: 0,
  }
}

/**
 * Test a webhook by sending a test payload
 */
export async function testWebhook(
  webhookId: string
): Promise<WebhookTestResult> {
  // Get webhook details
  const { data: webhook, error: webhookError } = await supabase
    .from('webhooks')
    .select('*')
    .eq('id', webhookId)
    .single()

  if (webhookError || !webhook) {
    throw new Error('Webhook not found')
  }

  // Build test payload
  const testPayload = {
    event: 'feedback.created',
    timestamp: new Date().toISOString(),
    webhook_id: webhook.id,
    test: true,
    data: {
      id: 'test-feedback-id',
      project_id: webhook.project_id,
      type: 'nps',
      content: {
        score: 9,
        comment: 'This is a test feedback from webhook configuration',
      },
      status: 'new',
      user_name: 'Test User',
      user_email: 'test@example.com',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    },
  }

  // Call our API endpoint to send the test webhook
  try {
    const response = await fetch('/api/webhooks/test', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        webhookId: webhook.id,
        url: webhook.url,
        secret: webhook.secret,
        payload: testPayload,
        template: webhook.template,
      }),
    })

    const result = await response.json()

    if (!response.ok) {
      return {
        success: false,
        error: result.error || 'Failed to send test webhook',
      }
    }

    return result
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

/**
 * Validate a webhook URL
 */
export function validateWebhookUrl(url: string): { valid: boolean; error?: string } {
  try {
    const parsedUrl = new URL(url)

    // Must be HTTPS (except for localhost)
    if (parsedUrl.protocol !== 'https:' && parsedUrl.hostname !== 'localhost') {
      return {
        valid: false,
        error: 'A URL deve usar HTTPS para segurança',
      }
    }

    // Check for common webhook URL patterns
    const validPatterns = [
      /hooks\.slack\.com/,
      /discord\.com\/api\/webhooks/,
      /discordapp\.com\/api\/webhooks/,
    ]

    const hasValidPattern = validPatterns.some((pattern) => pattern.test(url))

    return { valid: true }
  } catch {
    return {
      valid: false,
      error: 'URL inválida',
    }
  }
}

/**
 * Validate HMAC signature
 * This is a client-side helper for users to verify webhook signatures
 */
export function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  try {
    // In a real implementation, this would use the Web Crypto API
    // For now, we return a placeholder
    // The actual verification should be done server-side or using crypto.subtle
    return true
  } catch {
    return false
  }
}
